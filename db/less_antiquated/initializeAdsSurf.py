import warnings
warnings.filterwarnings("ignore", message="Moved to ase.neighborlist")

import sys,base64
import numpy 				as np
import matplotlib.pyplot 	as plt

from copy 			import deepcopy
from itertools 		import product 	# For cartesian product
from ase 			import io
from ase.db 		import connect
from ase.visualize 	import view
from emt  			import EMT
from surfacejob 	import SurfaceJob
from constraint 	import *
from filters 		import *
from db 			import plotQuery
from printParse 	import alphaNumSplit

from pymatgen 						import Molecule
from pymatgen.io.ase 				import AseAtomsAdaptor
from pymatgen.analysis.adsorption 	import AdsorbateSiteFinder


"""
"""

USER_APPROVAL = True

#############################
# Constraints on Job that
# Generated Initial Structure
##############################
essentialConstraints 	= [completed] 
otherConstraints 	 	= []

initialConstraints = essentialConstraints + otherConstraints
#################
# Surface domains
#################
bulkDomain 			= [x[0] for x in plotQuery('bulkresult',['aseid'],initialConstraints)]
facetDomain 		= [[1,1,1],[1,0,0]]
xyDomain 			= [[1,1],[2,2]]
layerDomain 		= [3,4]
constrainedDomain 	= [2]
symmetricDomain 	= [True,False]
vacuumDomain 		= [10]
vacancyDomain 		= [[],[1]] #indices of Atoms objects. Will I ever need to consider multiple vacancies?
adsDomain 			= [{},{'H':['H1']}]

###########
# Filters #
###########

filtsDuJour = 	[adsorbateFilter({'H':['H1']})]

filts = andFilters(essentialAdsSurfFilters + filtsDuJour)

##############
# Adsorbates #
##############
class Adsorbate(object):
	def __init__(self,pmg,vector): 
		self.pmg  	= pmg #should be centered around 0,0,0
		self.vector = vector
		self.offset = offset
		
CO = Molecule(["C", "O"], [[0, 0, 0],[0, 0, 1.3]])
H  = Molecule(["H"],[[0,0,0]])

molDict = {'CO':CO,'H':H}

#####################################
# Functions for constructing surfaces
#####################################


def adsorbedSurface(baresurface,adsorbates): 
	"""
	Adds adsorbates to bare surface
	"""
	slab 	= baresurface.copy()
	asf 	= AdsorbateSiteFinder(slab)

	b_sites = asf.find_adsorption_sites(distance=1.1,symm_reduce=0)['bridge']
	o_sites = asf.find_adsorption_sites(distance=1.1,symm_reduce=0)['ontop']
	h_sites = asf.find_adsorption_sites(distance=1.1,symm_reduce=0)['hollow']

	for ads,sites in adsorbates.items():
		a = molDict[ads]
		for (kind,num) in [alphaNumSplit(x) for x in sites]:
			asf = AdsorbateSiteFinder(slab)
			if   kind == 'B': slab=asf.add_adsorbate(a,b_sites[int(num)-1])
			elif kind == 'O': slab=asf.add_adsorbate(a,o_sites[int(num)-1])
			elif kind == 'H': slab=asf.add_adsorbate(a,h_sites[int(num)-1])
			else: raise ValueError, "Bad site character in "+str(sites)
	return slab

#############
# Main Script
#############

def main():
	pass
	"""
	for combo in domainProduct:
		i,fac,xy,l,c,sym,vac,ads,vacency=combo
		a = ???
		pmg_a= AseAtomsAdaptor.get_structure(a[0])
		unit = SpacegroupAnalyzer(pmg_a,symprec=0.1, angle_tolerance=5).get_conventional_standard_structure()
		
		gen = SlabGenerator(unit
						,fac
						,findHeight(unit,fac,l,sym)
						,vac,center_slab=sym,primitive=True,lll_reduce=True)

		slabs = gen.get_slabs()

		if len(slabs)>1: print "Warning, multiple slabs generated..."
		slab = slabs[0]
		slab.make_supercell(list(xy)+[1])
		bare = reorient_z(slab)

		adsorbed 	= adsorbedSurface(bare,ads)
		view(AseAtomsAdaptor.get_atoms(adsorbed))
		sys.exit()

		img 		= plot(bare)


		info = 	{'name': 		'%s_%s_%s'%(asedb.get(i).get('name'),'-'.join([str(x) for x in fac]),'x'.join([str(x) for x in xy]))
				,'kind': 		'bulk' # vs surface?
				,'vacuum':		vac
				,'facet': 		fac
				,'symmetric':	sym
				,'sites': 		img
				,'bare': 		True
				,'comments': 	'Autogenerated by initializeBareSurf'
				,'emt': 		atoms.get_potential_energy()
				,'relaxed': 	False}

		asedb = connect('/scratch/users/ksb/db/ase.db')

		db.write(atoms,key_value_pairs=info)"""


if __name__=='__main__':
	main()

